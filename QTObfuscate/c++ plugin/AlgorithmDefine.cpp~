
#include "AlgorithmDefine.h"


bool AlgorithmDefine::algorithm(string& s_input, string& s_sourceOutput, string& s_headerOutput)
{


int i_startQuote=0, i_endQuote=0, i_pos=0, i_num;

bool b_addNewLine = false;

string s_chars, s_rand, s_output, s_obfuscatedCodes, s_headerFile, s_randName, s_tempHeader,s_block ,s_blockHeader;


s_obfuscatedCodes = "#include \"XenusEgine.h\"\n";
s_blockHeader = "#include \"XenusEgine.h\"\n";

s_randName = RAND_NAME;
i_num = NUM_NAME;


while (i_pos < s_input.size()) {
	s_output.clear();

	// todo : remove comment
	// 		// ...
	//		/* ... */

	// todo : skip #include, #define

	// todo : move #include to header file

	// todo : obfuscate symbols

	// todo : quoted string

	// todo : randomise #define in header file

	if (s_input[i_pos] == '\"'){
		i_startQuote = i_pos;
		skipQuote(s_input, i_pos, '\"');
		i_endQuote = i_pos;
		//++i_pos;
		s_output.assign(s_input, i_startQuote, i_endQuote-i_startQuote);
		//modifyQuotedString(s_output,s_rand,s_headerFile);
		s_rand = nameGenerator(s_randName, i_num);
		s_obfuscatedCodes += s_rand + " ";

		s_block =  s_rand + " ";
		m_listOfBlocks.push_back(s_block);

		s_headerFile = "\n#define " + s_rand + " " + s_output;
		m_listOfDefine.push_back(s_headerFile);
		continue;	
	}
 
	if (s_input[i_pos] == '\'') {
		i_startQuote = i_pos;
		skipQuote(s_input, i_pos, '\'');
		i_endQuote = i_pos;
		//++i_pos;
		s_output.assign(s_input, i_startQuote, i_endQuote-i_startQuote);
		s_rand = nameGenerator(s_randName, i_num);
		s_obfuscatedCodes += s_rand + " ";

		s_block =  s_rand + " ";
		m_listOfBlocks.push_back(s_block);

		s_headerFile = "\n#define " + s_rand + " " + s_output;
		m_listOfDefine.push_back(s_headerFile);
		continue;	
	}

	if(s_input[i_pos] == '#' && s_input[i_pos+1] == 'i' && 
	    s_input[i_pos+2] == 'n' && s_input[i_pos+3] == 'c' ){ // check for #include
			int i_tempPos = i_pos;
			skipHeader(s_input, i_pos, '>');

			//i_pos = s_input.find('e', i_pos);
			//i_pos = skipHeader
			//i_endQuote = i_pos;
			//i_startQuote = s_input.find("<", i_tempPos, i_endQuote-i_tempPos);
			//if (i_startQuote == string::npos)
				//i_startQuote = s_input.find("\"", i_tempPos, i_endQuote-i_tempPos);
			//++i_pos;
			int i_bracketPos = i_tempPos;
			i_bracketPos  = s_input.find("<", i_bracketPos);
			if (i_bracketPos > i_pos || i_bracketPos == string::npos) {
				s_output.assign(s_input, i_tempPos, i_pos-i_tempPos);
				s_output.insert(0,"\n");
				m_listOfInclude.push_back(s_output);
				continue;
			}
			s_chars.assign(s_input, i_bracketPos, i_pos-i_bracketPos);
cout << "s_chars : " <<  s_chars<< endl;
			//s_rand = nameGenerator(s_randName, i_num);
			//s_tempHeader  = "\n#include " + s_output + "\n";
			modifyString(s_chars,s_rand,s_headerFile);	
			m_listOfDefine.push_back(s_headerFile);

			//s_output.assign(s_input, i_tempPos, i_pos-i_tempPos);
			//s_output.insert(0,"\n");
			s_output = "\n#include " + s_rand;
			m_listOfInclude.push_back(s_output);

			s_chars.clear();
			
			//b_addNewLine = true;	
			continue;		
	}

	if(s_input[i_pos] == '(' ){ // check for #include
			++i_pos;
			s_output = " ( ";
			s_rand = nameGenerator(s_randName, i_num);
			s_obfuscatedCodes += s_rand + " ";

			s_block =  s_rand + " ";
			m_listOfBlocks.push_back(s_block);

			s_headerFile = "\n#define " + s_rand + " " + s_output;
			m_listOfDefine.push_back(s_headerFile);
			continue;			
	}

	if(s_input[i_pos] == ')' ){ // check for #include
			++i_pos;
			s_output = " ) ";
			s_rand = nameGenerator(s_randName, i_num);
			s_obfuscatedCodes += s_rand + " ";

			s_block =  s_rand + " ";
			m_listOfBlocks.push_back(s_block);

			s_headerFile = "\n#define " + s_rand + " " + s_output ;
			m_listOfDefine.push_back(s_headerFile);
			continue;		
	}

	if(s_input[i_pos] == ',' ){ // check for #include
			++i_pos;
			s_output = " , ";
			s_rand = nameGenerator(s_randName, i_num);
			s_obfuscatedCodes += s_rand + " ";

			s_block =  s_rand + " ";
			m_listOfBlocks.push_back(s_block);

			s_headerFile = "\n#define " + s_rand + " " + s_output;
			m_listOfDefine.push_back(s_headerFile);
			continue;		
	}

	s_output.clear();
	s_chars.clear();
	//while (!isalnum(s_input[i_pos]) && !isspace(s_input[i_pos]) {
	while (!isspace(s_input[i_pos]) && i_pos < s_input.size()) {
cout << "s_chars.push_back(s_input[i_pos]) : " << s_input[i_pos] << endl;
		if (s_input[i_pos] == '(') {
			//b_foundOpenBraces = true;
			--i_pos;
			break;
		}
		if (s_input[i_pos] == ')') {
			//b_foundCloseBraces = true;
			--i_pos;
			break;
		}

		if (s_input[i_pos] == '\"') {
			--i_pos;
			break;
		}
		if (s_input[i_pos] == '\'') {
			--i_pos;
			break;
		}

		if (s_input[i_pos] == ',') {
			--i_pos;
			break;
		}

		s_chars.push_back(s_input[i_pos]);
		++i_pos;
	}

	modifyString(s_chars,s_rand,s_headerFile);

	if (!s_chars.empty())
		s_output += s_rand + " ";
/*
	if (!s_chars.empty() && b_addNewLine) {
		s_tempHeader += s_rand + " ";
		s_tempHeader += "\n";
		b_addNewLine = false;
	}
*/
/*
	if (b_foundOpenBraces) {
		s_output += " ( ";
		b_foundOpenBraces = false;
	}
	if (b_foundCloseBraces) {
		s_output += " ) ";
		b_foundCloseBraces = false;
	}
*/
	if (!s_output.empty()) {
		s_obfuscatedCodes += s_output;

		s_block =  s_rand + " ";
		m_listOfBlocks.push_back(s_block);

	}
/*
	if (!s_tempHeader.empty()) {
		//m_listOfDefine.push_back(s_tempHeader);
		s_tempHeader.clear();
	}
*/
	++i_pos;
	}

	string s_fileName = "sorce.cpp", s_headerFileName = "XenusEgine.h";

	//s_obfuscatedCodes.insert(0, s_sourceHeader);
	//writeToFile(s_fileName,s_obfuscatedCodes);

	string s_formated;
	format(m_listOfBlocks,s_formated);
	//s_formated.insert(0,s_blockHeader);
	//writeToFile(s_fileName,s_formated);
	//s_sourceOutput.clear();
	s_sourceOutput = s_formated;

	//s_headerOutput.clear();
	int i_intRand;
	set<int> set_checkDuplicate;
	//for (int i=0; i<m_listOfDefine.size(); ++i) {
       //ofstream out(s_headerFileName.c_str());



	s_headerOutput += "#ifndef XENUS_ENGINE\n#define XENUS_ENGINE\n";

	while (set_checkDuplicate.size() != m_listOfDefine.size()) {
		i_intRand = rand() % m_listOfDefine.size();
//cout << i_intRand << " ";
		if(set_checkDuplicate.insert(i_intRand).second == true)
			s_headerOutput += m_listOfDefine[i_intRand];
      			 //out <<  m_listOfDefine[i_intRand];
	}
	for (int i=0; i<m_listOfInclude.size(); ++i)
		s_headerOutput += m_listOfInclude[i];
		//out <<  m_listOfInclude[i];

		s_headerOutput += "\n#endif\n";
   	// out.close();
}



void AlgorithmDefine::modifyString(string& s_input, string& s_randOutput, string& s_output)
{
	int i_num;
	string s_name, s_name2, s_argument, s_randName, s_headerFile;
	vector<int> v_charPos;
	vector<string> v_listOfArgument;

	if (s_input.empty())
		return;

	randomiseString(s_input, v_charPos);

	i_num = NUM_NAME;
	s_randName = RAND_NAME;

	for (int i=0; i<s_input.size(); ++i) {
		s_argument = nameGenerator(s_randName, i_num);
		v_listOfArgument.push_back(s_argument);
	}

	//vector<string> v_argumentArrange(v_charPos.size());
	//for (int i=0; i<v_charPos.size(); ++i) {
	//	cout <<  "v_charPos: " << v_charPos[i] << endl;

	//}

	vector<string> v_argumentArrange;
	for (int i=0; i<v_charPos.size(); ++i) {
		if (v_charPos[i] != -1)
			v_argumentArrange.push_back( v_listOfArgument[v_charPos[i]] );
		//cout <<  "v_argumentArrange: " << v_argumentArrange[i] << endl;
		//cout <<  "v_charPos: " << v_charPos[i] << endl;
		//cout <<  "v_listOfArgument: " <<  v_listOfArgument[v_charPos[i]]  << endl;
	}

	i_num = NUM_NAME;
	s_randName = RAND_NAME;
	s_name = nameGenerator(s_randName, i_num);
	s_name2 = nameGenerator(s_randName, i_num);

	s_headerFile = "\n#define " + s_name + "(";
	for (int i=0; i<v_listOfArgument.size(); ++i) {
		s_headerFile += v_listOfArgument[i];
		if (i != v_listOfArgument.size()-1)
			s_headerFile.push_back(',');

	}
	s_headerFile += ")";
	for (int i=0; i<v_argumentArrange.size(); ++i) {
		s_headerFile += v_argumentArrange[i];
		if (i == v_argumentArrange.size()-1)
			break;

		if (i != v_argumentArrange.size()-1 
			&& isalnum(s_input[v_charPos[i]]) && isalnum(s_input[v_charPos[i+1]]) 
			|| s_input[v_charPos[i]] == '_' || s_input[v_charPos[i+1]] == '_' 
			|| s_input[v_charPos[i]] == '<' && s_input[v_charPos[i+1]] == '<'
			|| s_input[v_charPos[i]] == '>' && s_input[v_charPos[i+1]] == '>' 
			|| s_input[v_charPos[i]] == '=' && s_input[v_charPos[i+1]] == '=' 
			|| s_input[v_charPos[i]] == '!' && s_input[v_charPos[i+1]] == '=' 
			|| s_input[v_charPos[i]] == '%' && s_input[v_charPos[i+1]] == '=' 
			|| s_input[v_charPos[i]] == '^' && s_input[v_charPos[i+1]] == '='
			|| s_input[v_charPos[i]] == '*' && s_input[v_charPos[i+1]] == '=' 
			|| s_input[v_charPos[i]] == '+' && s_input[v_charPos[i+1]] == '=' 
			|| s_input[v_charPos[i]] == '-' && s_input[v_charPos[i+1]] == '='
			|| s_input[v_charPos[i]] == '/' && s_input[v_charPos[i+1]] == '='
			|| s_input[v_charPos[i]] == ':' || s_input[v_charPos[i+1]] == ':')
			s_headerFile += "##";
		else
			s_headerFile += " ";			
	}
	s_output += s_headerFile;
	m_listOfDefine.push_back(s_headerFile);

	s_headerFile = "\n#define " + s_name2 + " " + s_name + "(";
	for (int i=0; i<s_input.size(); ++i) {
		s_headerFile.push_back(s_input[i]);
		if (i != s_input.size()-1)
			s_headerFile.push_back(',');

	}
	s_headerFile += ")";
	s_output += s_headerFile;
	m_listOfDefine.push_back(s_headerFile);

	//s_headerFile = "\n" + s_input + "\n";
	//s_output += s_headerFile;

	s_randOutput = s_name2;
}

void AlgorithmDefine::modifyOther(string& s_input, string& s_randOutput, string& s_output)
{
	int i_num;
	string s_name, s_name2, s_argument, s_randName, s_headerFile;
	vector<int> v_charPos;
	vector<string> v_listOfArgument;

	if (s_input.empty())
		return;

	if (s_input.find("(") != string::npos 
		|| s_input.find(")") != string::npos
		|| s_input.find("#") != string::npos
		|| s_input.find(",") != string::npos)
		return;

	randomiseString(s_input, v_charPos);

	i_num = NUM_NAME;
	s_randName = RAND_NAME;

	for (int i=0; i<s_input.size(); ++i) {
		s_argument = nameGenerator(s_randName, i_num);
		v_listOfArgument.push_back(s_argument);
	}

	//vector<string> v_argumentArrange(v_charPos.size());
	//for (int i=0; i<v_charPos.size(); ++i) {
	//	cout <<  "v_charPos: " << v_charPos[i] << endl;

	//}

	vector<string> v_argumentArrange;
	for (int i=0; i<v_charPos.size(); ++i) {
		if (v_charPos[i] != -1)
			v_argumentArrange.push_back( v_listOfArgument[v_charPos[i]] );
		//cout <<  "v_argumentArrange: " << v_argumentArrange[i] << endl;
		//cout <<  "v_charPos: " << v_charPos[i] << endl;
		//cout <<  "v_listOfArgument: " <<  v_listOfArgument[v_charPos[i]]  << endl;
	}

	i_num = NUM_NAME;
	s_randName = RAND_NAME;
	s_name = nameGenerator(s_randName, i_num);
	s_name2 = nameGenerator(s_randName, i_num);

	s_headerFile = "\n#define " + s_name + "(";
	for (int i=0; i<v_listOfArgument.size(); ++i) {
		s_headerFile += v_listOfArgument[i];
		if (i != v_listOfArgument.size()-1)
			s_headerFile.push_back(',');

	}
	s_headerFile += ")";
	for (int i=0; i<v_argumentArrange.size(); ++i) {
		s_headerFile += "#" + v_argumentArrange[i];
		//if (i == v_argumentArrange.size()-1)
			//break;

		//if (i != v_argumentArrange.size()-1)
			//s_headerFile += "#";
		//else
			//s_headerFile += " ";			
	}
	s_output += s_headerFile;
	m_listOfDefine.push_back(s_output);

	s_headerFile = "\n#define " + s_name2 + " " + s_name + "(";
	for (int i=0; i<s_input.size(); ++i) {
		s_headerFile.push_back(s_input[i]);
		if (i != s_input.size()-1)
			s_headerFile.push_back(',');

	}
	s_headerFile += ")";
	s_output += s_headerFile;
	m_listOfDefine.push_back(s_output);

	//s_headerFile = "\n" + s_input + "\n";
	//s_output += s_headerFile;

	s_randOutput = s_name2;
}

void AlgorithmDefine::writeToFile(const string& s_fileName,const string& s_input)
{
       ofstream out(s_fileName.c_str());
       out << s_input;
       out.close();
}

void AlgorithmDefine::skipQuote(const string& s_input, int& i_skip, char c_quote) 
{
	for(int i=i_skip; i<s_input.size(); ++i)
	{	
		while(s_input[i] == c_quote) { // enter quoted string
			++i;
			while(s_input[i] != c_quote || s_input[i-1]== '\\') { // skip quoted string
				++i;
			}
			++i;
			i_skip = i;
			return;
		}
	}
}

void AlgorithmDefine::skipHeader(const string& s_input, int& i_skip, char c_bracket) 
{
	int i = i_skip;

	while(s_input[i] == '#' && s_input[i+1] == 'i' && 
		   	   s_input[i+2] == 'n' && s_input[i+3] == 'c' ) // check for #include
	{
		while (s_input[i] != '>')
		{
			 if(s_input[i] == '\"') {
		                skipQuote(s_input, i, '\"');
				i_skip = i;
				break;
			}

			++i;
		}

		if(s_input[i] == '>')
			++i;

		i_skip = i;

	}
}

void AlgorithmDefine::randomiseString(string& s_inOutput, vector<int>& v_charPos)
{
	int i_randNum=0, i_randNum1=0, i_pos=0;
	string s_output, s_checkForDuplicate, s_redundancy;
	string s_rand = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_-=[]/?.<>;:$%^&*!";
	set<int> set_randNum;
	set<int> set_randNum1;

	v_charPos.clear();
	while (set_randNum.size() != (s_inOutput.size() * ADD_REDUNDANCY) ) {
		i_randNum = rand() % 72;
		if (set_randNum.insert(i_randNum).second == true) {
			while (s_inOutput.find(s_rand[i_randNum]) != string::npos) {
				i_randNum = rand() % 26;
			}
			s_redundancy.push_back(s_rand[i_randNum]);
				

		}
	}

	set_randNum.clear();
	int i=0;
	vector<int> v_tempCharPos;  //(s_redundancy.size(),-1);
	while (set_randNum.size() != s_inOutput.size() ) {
		i_randNum = rand() % s_inOutput.size(); 
		if (set_randNum.insert(i_randNum).second == true) {
			//i_randNum = rand() % s_inOutput.size();
			i_randNum1 = rand() % s_redundancy.size();
			while (set_randNum1.insert(i_randNum1).second != true) {
				i_randNum1 = rand() % s_redundancy.size();
			}
				i_pos = s_checkForDuplicate.find(s_inOutput[i]);
				if (i_pos == string::npos) {
					s_checkForDuplicate.push_back(s_inOutput[i]);


			s_redundancy.replace(i_randNum1, 1, 1, s_inOutput[i]);
			++i;
			v_tempCharPos.push_back(i_randNum1);
			}
				else {
					i_pos = s_redundancy.find(s_inOutput[i]);
					v_tempCharPos.push_back(i_pos);
					++i;
				}
	
		}
	}
v_charPos = v_tempCharPos;
s_inOutput = s_redundancy;	
		
}


string AlgorithmDefine::nameGenerator(string& s_name, int i_num)
{
	string s_output;
	int i_randNum=0;
	
	for (int i=0; i < i_num; ++i) {
		i_randNum = rand() % s_name.size();
		s_output.push_back(s_name[i_randNum]);
	}
	
	return s_output;
}





void AlgorithmDefine::format(vector<string>& v_input, string& s_output)
{

int i_line = 0;
int i_numBlocks = v_input.size();
if (i_numBlocks <= 20)
	return;

i_numBlocks -= 20;

float i_quotients = 0.0;
i_quotients = i_numBlocks / 7;

//cout << i_quotients<<endl;

int i_linesOfBlocksOnTop = 0;
if (i_quotients > 1) {
	i_linesOfBlocksOnTop = i_quotients / 2;
//cout << i_linesOfBlocksOnTop<<endl;
	i_line = 1;
	for (int k=0; k<i_linesOfBlocksOnTop*7; ++k) {
			s_output += v_input[k] + " ";
			if ((i_line % 7) == 0) {
				s_output += "\n";
			}
			++i_line;
	}
}

s_output += "\n";

int i_patternPos = 0;
i_patternPos = i_linesOfBlocksOnTop * 7;
s_output += 
	// first line
	v_input[i_patternPos] + addSpace(11) + v_input[i_patternPos+1] + addSpace(11)
	+ v_input[i_patternPos+2] + " " + v_input[i_patternPos+3] + " " 
	+ v_input[i_patternPos+4] + " \n"

	// second line
	+ addSpace(5) + v_input[i_patternPos+5] + addSpace(2)
	+ v_input[i_patternPos+6] + addSpace(15) + v_input[i_patternPos+7] + " \n"

	// third line
	+ addSpace(10) + v_input[i_patternPos+8] + addSpace(21)
	+ v_input[i_patternPos+9] + " " + v_input[i_patternPos+10] + " " 
	+ v_input[i_patternPos+11] + " \n"

	// fourth line
	+ addSpace(5) + v_input[i_patternPos+12] + addSpace(2)
	+ v_input[i_patternPos+13] + addSpace(15) + v_input[i_patternPos+14] + " \n"

	// fifth line
	+ v_input[i_patternPos+15] + addSpace(11) + v_input[i_patternPos+16] + addSpace(11)
	+ v_input[i_patternPos+17] + " " + v_input[i_patternPos+18] + " " 
	+ v_input[i_patternPos+19] + " \n";

s_output += "\n";

	i_patternPos += 20;
	i_line = 0;
	for (int k=i_patternPos; k<v_input.size(); ++k) {
			s_output += v_input[k] + " ";
			++i_line;
			if ((i_line % 7) == 0) {
				i_line = 0;
				s_output += "\n";
			}
	}
	//s_output += "\n";

}

string AlgorithmDefine::addSpace(int i_numSpaces)
{
	string s_output;
	for (int i=0; i< i_numSpaces; ++i)
		s_output += " ";

	return s_output;
}

char rand_alnum()
{
    char c;
    while (!std::isalpha(c = static_cast<char>(std::rand())));
    return c;
}

std::string AlgorithmDefine::rand_alnum_str (std::string::size_type sz)
{	
    std::string s;
    s.reserve  (sz);
    generate_n (std::back_inserter(s), sz, rand_alnum);
    return s;
}


