
#include "ReverseAlgorithm.h"

void ReverseAlgorithm::setUpMapping(const string& s_input, map<string,string>& m_output)
{
        if(s_input.empty())
            return;

        string s_string;
        size_t i_firstDelim = 0, i_secondDelim = 0;
        vector<string> v_string;
	m_output.clear();

        i_firstDelim = s_input.find_first_of(';');
        i_secondDelim = s_input.find_first_of(';',i_firstDelim+1);
        s_string.assign(s_input.begin(), s_input.begin()+i_firstDelim);
        v_string.push_back(s_string);

        while(i_secondDelim != string::npos) {
            s_string.assign(s_input.begin()+i_firstDelim+1, s_input.begin()+i_secondDelim);
            v_string.push_back(s_string);

            i_firstDelim = s_input.find_first_of(';',i_firstDelim+1);
            i_secondDelim = s_input.find_first_of(';',i_secondDelim+1);
        }

        i_firstDelim =  0;
        i_secondDelim =  0;

	for(int i=0; i<v_string.size(); ++i)
	{
		m_output.insert (pair<string,string>(v_string[i],v_string[i+1]) );
		++i;
	}
}

void ReverseAlgorithm::reverseModifyString(string& output,
						const string& s_input,
						const vector<string>& v_targetWords,
						map<string,string>& mymap)
{
    if(s_input.empty() || v_targetWords.empty())
        return;

	locale loc;
	string s_randomWord, s_originalWord;
	int i_indexOfTargetWords=0, i_endOfQuote=0;
	bool b_eof = false; // end of file
	size_t found=0;
	map<string,string>::iterator m_iter;

	output.clear();

	if( v_targetWords.empty()) {
		return;
	}

        for(int i=0; i<s_input.size(); ++i)
        {
                if(i_indexOfTargetWords < v_targetWords.size() )
                        s_randomWord =  v_targetWords[i_indexOfTargetWords];

                if(found < s_input.size() && found != string::npos) {
                        found = s_input.find(s_randomWord,found);
			if(s_input[found-1] == '\"')
				found = s_input.find(s_randomWord,found+1);
		}
                while(found!=i) {
                        output.append(1,s_input[i]);
                        ++i;

			if(s_input[i] == '#' && s_input[i+1] == 'i' && 
		   	   s_input[i+2] == 'n' && s_input[i+3] == 'c' ) { // check for #include
				skipHeader(s_input, i_endOfQuote, '>');

				if(i_endOfQuote > found) {
					found = s_input.find(s_randomWord,found);
					if(s_input[found-1] == '\"' || s_input[found-1] == '<')
						found = s_input.find(s_randomWord,found+1);		
				}
			}

		        if(s_input[i] == '\"') {
		                skipQuote(s_input, i_endOfQuote, '\"');
				if(i_endOfQuote > found) {
					found = s_input.find(s_randomWord,found);
					if(s_input[found-1] == '\"')
						found = s_input.find(s_randomWord,found+1);		
				}

			}

		        if(s_input[i] == '\'') {
		                skipQuote(s_input, i_endOfQuote, '\'');
				if(i_endOfQuote > found) {
					found = s_input.find(s_randomWord,found);
					if(s_input[found-1] == '\"')
						found = s_input.find(s_randomWord,found+1);		
				}
			}

                        if(i >= s_input.size()) {
                                b_eof = true;
                                break;
                        }
                }

                if(b_eof) break;

                if(isdigit(s_randomWord[0],loc)){
                        output.append(s_randomWord);
                        found += s_randomWord.size();
                        i = found-1;
                        ++i_indexOfTargetWords;
                }

                if(found == i){
			if(!s_randomWord.empty())
                       		m_iter=mymap.find(s_randomWord);

                        if( m_iter != mymap.end())
                                s_originalWord = (*m_iter).second;cout << (*m_iter).second << endl;

			if(!s_originalWord.empty())
                             output.append(s_originalWord);

                        found += s_randomWord.size();
                        i = found-1;
                        ++i_indexOfTargetWords;
                }
        }
}

void ReverseAlgorithm::formatFile(const string& s_input, string& s_output)
{
        string s_tabToAppend;
	   	int i_tabToAppend = 0;
		s_output.clear();

                for(int i=0; i<s_input.size();++i) {

                        s_tabToAppend.clear();

                        for(int k=0; k<i_tabToAppend; ++k) {
                                s_tabToAppend.append("\t");
                        }
                        if(s_input[i] == '{') {
                                s_output.append("\n");
                                s_output.append(s_tabToAppend);
                                s_output.append("{");
                                s_output.append("\n");
                                s_output.append("\t");
                                s_output.append(s_tabToAppend);
                                ++i_tabToAppend;
                        }
                        else if(s_input[i] == '}') {
                                s_output.append("\n");
				if(!s_tabToAppend.empty())
	                                s_tabToAppend.erase(s_tabToAppend.begin());
				if(!s_tabToAppend.empty())
                               		 s_output.append(s_tabToAppend);

                                s_output.append("}");
                                s_output.append("\n");
                               // s_output.append("\t");
                                --i_tabToAppend;
                        }
                        else if(s_input[i] == ';') {
                                s_output.append(";");
                                s_output.append("\n");
                                s_output.append(s_tabToAppend);
                        }
                        else {
                                s_output.append(1, s_input[i]);
                        }
                }
                cout << s_output << endl;
}


void ReverseAlgorithm::addWordsToList(const string& s_input, vector<string>& v_targetWords)
{
        locale loc;
        string s_temp;

        for(int i=0; i<s_input.size(); ++i)
        {
                if(s_input[i] == '\"')
                        skipQuote(s_input, i, '\"');
                if(s_input[i] == '\'')
                        skipQuote(s_input, i, '\'');

if(s_input[i] == '#' && s_input[i+1] == 'i' && 
		   	   s_input[i+2] == 'n' && s_input[i+3] == 'c' ) // check for #include
		skipHeader(s_input, i, '>');

		s_temp.clear();

                while(isalnum(s_input[i],loc) || s_input[i]=='_')
                {
                	s_temp.append(1,s_input[i]);
                	++i;
                }

                if(!s_temp.empty())
                	v_targetWords.push_back(s_temp);
        }
}

void ReverseAlgorithm::removeWordsFromList(map<string,string> m_input, vector<string>& v_targetWords)
{
	set<string> set_input;
	map<string,string>::iterator it;

	for ( it=m_input.begin() ; it != m_input.end(); it++ ) {
	    set_input.insert((*it).first);
	}

        string s_temp;
        vector<string> v_output;
        set<string>::iterator set_it;

        for(int i=0; i<v_targetWords.size(); ++i)
        {
                s_temp = v_targetWords[i];

                if( (set_it=set_input.find(s_temp)) != set_input.end() ){
                        v_output.push_back(s_temp);
                }
        }

        v_targetWords.clear();
        v_targetWords.assign(v_output.begin(), v_output.end());
}


void ReverseAlgorithm::skipQuote(const string& s_input, int& i_skip, char c_quote)
{
        for(int i=i_skip; i<s_input.size(); ++i)
        {
                while(s_input[i] == c_quote) { // enter quoted string
                        ++i;
                        while(s_input[i] != c_quote && s_input[i-1]!= '\\') { // skip quoted string
                                ++i;
                        }
                        ++i;
                        i_skip = i;
                        return;
                }
        }
}

void ReverseAlgorithm::convertQuotedHexToString(string& s_input)
{
        size_t i_firstQuote;
        size_t i_secondQuote;
        size_t i_sizeOfQuotedString;
        vector<string> v_listOfQuotedString;
        string s_word;
        string s_hex;
 	string s_quotedString;
        int i_sizeToRepalce;
        int i_posToReplace;

	// find and skip header files
	//int i_headerPos=0;
	//int i_newlinePos=0;
/*
	i_headerPos = s_input.rfind("#include");

	if(i_headerPos!=string::npos) {
		i_newlinePos = s_input.find("\n", i_headerPos);
	}
	// find and skip header files (end)
*/

                i_firstQuote = s_input.find_first_of("\"", 0);
                i_secondQuote = s_input.find_first_of("\"",i_firstQuote+1);
		while(s_input[i_secondQuote-1] == '\\') {
			i_secondQuote = s_input.find_first_of("\"",i_secondQuote+1);
		}

                while(i_firstQuote != string::npos && i_secondQuote != string::npos) {
                        i_sizeOfQuotedString = i_secondQuote - i_firstQuote - 1;
                        s_quotedString.assign(s_input, i_firstQuote+1, i_sizeOfQuotedString);
			if(s_quotedString.find(".h") == string::npos)
                        	v_listOfQuotedString.push_back(s_quotedString);
                        i_firstQuote = s_input.find_first_of("\"",i_secondQuote+1);
                        i_secondQuote = s_input.find_first_of("\"",i_firstQuote+1);
			while(s_input[i_secondQuote-1] == '\\') {
				i_secondQuote = s_input.find_first_of("\"",i_secondQuote+1);
			}
                }
                for(int i=0; i<v_listOfQuotedString.size(); ++i) {
                                //cout << v_listOfQuotedString[i] << endl;
                        if(s_input.find(v_listOfQuotedString[i]) != string::npos) {
                                s_word = v_listOfQuotedString[i];
                                i_posToReplace = s_input.find(s_word);
                                i_sizeToRepalce = s_word.size();
                                s_hex.clear();
                                hexToString(s_word, s_hex);
                                s_input.replace ( i_posToReplace, i_sizeToRepalce, s_hex, 0, s_hex.size() );
                        }
                }
}

void ReverseAlgorithm::hexToString(const string& s_input, string& output)
{

        output.clear();
        size_t found, found2;
        string s_hex;
        stringstream ss;
        int i_hexToInt;

        found=s_input.find_first_not_of("\\x");

        if(found != string::npos)
                found2=s_input.find("\\x",found);

        while (found!=string::npos) {
                s_hex.clear();
                ss.str("");
                ss.clear();

                if(found2 != string::npos) {
                        s_hex.append(s_input,found, found2-found);

                        ss << hex <<s_hex;
                        ss >> i_hexToInt;

                        output.append(1, (char) i_hexToInt);

			if(s_hex.find(".")!=string::npos)
				output.append(".");
			if(s_hex.find("\n")!=string::npos)
				output.append("\\n");
			if(s_hex.find("t")!=string::npos)
				output.append("\\t");

                        found=s_input.find_first_not_of("\\x",found2);
                        found2=s_input.find("\\x",found);


                }
                else {
                        s_hex.append(s_input,found, s_input.size()-found);

                        ss << hex <<s_hex;
                        ss >> i_hexToInt;

                        output.append(1, (char) i_hexToInt);

			if(s_hex.find(".")!=string::npos)
				output.append(".");
			if(s_hex.find("n")!=string::npos)
				output.append("\\n");
			if(s_hex.find("t")!=string::npos)
				output.append("\\t");
                        break;
                }
        }
}

void ReverseAlgorithm::skipHeader(const string& s_input, int& i_skip, char c_bracket) 
{
	int i = i_skip;

	while(s_input[i] == '#' && s_input[i+1] == 'i' && 
		   	   s_input[i+2] == 'n' && s_input[i+3] == 'c' )// check for #include
	{
		while (s_input[i] != '>')
		{
			 if(s_input[i] == '\"') {
		                skipQuote(s_input, i, '\"');
				i_skip = i;
				break;
			}

			++i;
		}

		if(s_input[i] == '>')
			++i;

		i_skip = i;

	}
}


